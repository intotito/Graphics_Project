<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title></title>
    <style type="text/css">
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.5/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
    <!--    <script src="OrbitControls.js"></script> -->

    <script type="text/javascript">

        class SAMLauncher {
            dim = {
                x: 1,
                y: 0.32,
                z: 0.5
            }
            trans = {
                x: -this.dim.x,
                y: 0,//this.dim.y / 2,
                z: 0
            };
            scale = {
                x: 2,
                y: 2,
                z: 2
            };
            constructor(x, y) {
                this.dim.x *= this.scale.x;
                this.dim.y *= this.scale.y;
                this.dim.z *= this.scale.z;
                this.SAM = new THREE.Group();
                let shape = new THREE.Shape();
                shape.moveTo(0 + this.trans.x, 0 + this.trans.y);
                shape.lineTo(0 + this.trans.x, this.dim.y / 2 + this.trans.y);
                shape.lineTo(0.6 * this.dim.x + this.trans.x, this.dim.y / 2 + this.trans.y);
                shape.lineTo(0.6 * this.dim.x + this.trans.x, this.dim.y + this.trans.y);
                shape.lineTo(0.85 * this.dim.x + this.trans.x, this.dim.y + this.trans.y);
                shape.lineTo(this.dim.x + this.trans.x, this.dim.y * 0.75 + this.trans.y);
                shape.lineTo(this.dim.x + this.trans.x, this.dim.y * 0.15 + this.trans.y);
                shape.lineTo(this.dim.x * 0.95 + this.trans.x, 0 + this.trans.y);
                shape.lineTo(this.dim.x * 0.9 + this.trans.x, 0 + this.trans.y);
                shape.arc(-this.dim.x * 0.15 / 2, 0, this.dim.x * 0.15 / 2, 0, Math.PI, false);
                shape.lineTo(this.dim.x * 0.2 + this.trans.x, 0 + this.trans.y);
                shape.arc(-this.dim.x * 0.15 / 2, 0, this.dim.x * 0.15 / 2, 0, Math.PI, false);
                shape.lineTo(0 + this.trans.x, 0 + this.trans.y);
                let extrudeSettings = {
                    steps: 1,
                    depth: this.dim.z,
                    bevelEnabled: true,
                    bevelThickness: 0,
                    bevelSize: 0,
                    bevelSegment: 2
                };
                let geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings)
                console.log(-this.dim.z / 2);
                geometry.translate(0, 0, this.dim.z / -2);
                this.mesh = new THREE.Mesh(geometry,
                    new THREE.MeshPhongMaterial({ color: 0x00ff00 }));



                let shape1 = new THREE.Shape();
                shape1.moveTo(this.dim.x * 0.2 + this.trans.x, 0 + this.trans.y);
                shape1.arc(-this.dim.x * 0.15 / 2, 0, this.dim.x * 0.15 / 2, 0, Math.PI, false);

                let extrudeSettings1 = {
                    steps: 2,
                    depth: this.dim.z * 1.1,
                    bevelEnabled: true,
                    bevelThickness: 0,
                    bevelSegment: 2,
                    bevelSize: 0
                };

                this.mesh1 = new THREE.Mesh(new THREE.ExtrudeGeometry(shape1, extrudeSettings1),
                    new THREE.MeshPhongMaterial({ color: 0x2F2F2F }));
                this.mesh1.geometry.translate(0, 0, -this.dim.z * 1.1 / 2);

                this.mesh2 = new THREE.Mesh(new THREE.ExtrudeGeometry(shape1, extrudeSettings1),
                    new THREE.MeshPhongMaterial({ color: 0x2F2F2F }));

                console.log(this.mesh2.geometry);
                this.mesh2.geometry.translate(0.7 * this.dim.x, 0, -this.dim.z * 1.1 / 2);



                let shape2 = new THREE.Shape();
                let h = this.dim.y * 0.25;
                let w = this.dim.z;
                let tx = -w / 2;
                let ty = 0;// this.dim.y / 2;// -h / 2;
                let r = (h * 0.75) / 2;



                shape2.moveTo(tx + 0, ty + 0);
                shape2.lineTo(tx + 0, ty + h);
                shape2.lineTo(tx + w, ty + h);
                shape2.lineTo(tx + w, ty + 0);
                shape2.lineTo(tx + 0, ty + 0);

                for(let i = 0; i < 4; i++){
                    let s = new THREE.Shape();
                    s.moveTo(tx  + (w / 4) * i + ((w / 4) - 2 * r) / 2, ty + h / 2);
                    s.arc(r, 0, r, 0, 2 * Math.PI, false);
                  shape2.holes.push(s);
                }


                // shape2.moveTo(this.dim.x * 0.2 + this.trans.x, 0 + this.trans.y);
                // shape2.arc(-this.dim.x * 0.15 / 2, 0, this.dim.x * 0.15 / 2, 0, Math.PI, false);

                let extrudeSettings2 = {
                    steps: 2,
                    depth: this.dim.x * 0.6,
                    bevelEnabled: true,
                    bevelThickness: 0,
                    bevelSegment: 2,
                    bevelSize: 0
                };
                this.mesh3 = new THREE.Mesh(new THREE.ExtrudeGeometry(shape2, extrudeSettings2),
                    new THREE.MeshPhongMaterial({ color: 0x024F02 }));
          //      this.mesh3.geometry.translate(0, this.dim.y * 0.5 + h / 2, -this.dim.x * 0.6 / 2);
            
            //    this.mesh3.rotation.y = Math.PI / 2;
            //   this.mesh3.rotation.x = -Math.PI / 4;
           this.mesh3.rotateY(Math.PI / 2);
          //     this.mesh3.geometry.translate(0, 0, -0.2 * this.dim.x);
               this.mesh3.position.x = -this.dim.x / 2;
               this.mesh3.position.y = this.dim.y / 2;
                console.log(this.mesh3.geometry);
               
               

       //         this.mesh3.geometry.translate(0.7 * this.dim.x, 0, -this.dim.z * 1.1 / 2);
        //        this.mesh3.position.y = this.dim.y / 2;

                this.SAM.add(this.mesh, this.mesh1, this.mesh2, this.mesh3);

                this.SAM.rotation.y = 3 * Math.PI / 2;


            }

            getMesh() {
                return this.SAM;
            }

            rotateY(angle) {
                //  return;


                let cosB = Math.cos(angle);
                let sinB = Math.sin(angle);
                let x = this.SAM.position.x;
                let z = this.SAM.position.z;
                let px = this.scale.x * 0;
                let pz = this.dim.z / 2;
                let xx = (x * cosB - z * sinB + px * (1 - cosB) + pz * sinB);
                let zz = (x * sinB + z * cosB + pz * (1 - cosB) - px * sinB);

                //           console.log(this.SAM.getWorldPosition());

                //         this.SAM.position.x = xx;
                //         this.SAM.position.z = zz;

                //        this.SAM.updateMatrix();
                // let tx = (this.SAM.position.x * cosB + this.SAM.position.z * -sinB + this.dim.x * this.scale * (1 - cosB) + this.dim.z * this.scale * sinB);
                // let tz = (this.SAM.position.x * sinB + this.SAM.position.z * cosB + this.dim.z * this.scale * (1 - cosB) - this.dim.x * this.scale * sinB);
                // console.log("tx = " + tx + " tz = " + tz);
                //  this.SAM.position.x = -this.dim.x * this.scale / 2;
                // this.SAM.position.y = -this.dim.y * this.scale / 2;
                //  this.SAM.position.z = -this.dim.z / 2;//-this.dim.z * this.scale;
                // this.SAM.position.z = -this.dim.z / 2 / this.scale.z;
                // //  this.SAM.updateMatrix();
          //      this.SAM.rotation.y = angle / 2;
          
  this.mesh3.rotateX(toRad(-0.1));  
;
                // this.mesh3.rotation.x = angle;
                //  this.SAM.updateMatrix();
                //    this.SAM.position.z = (this.dim.x / 2/ this.scale.x * Math.cos(angle) + this.dim.z / 2 / this.scale.z * Math.sin(-angle));
                //    this.SAM.position.x = (this.dim.x / 2 / this.scale.x * Math.sin(angle) + this.dim.z / 2 / this.scale.z * Math.cos(angle));
                //     this.SAM.updateMatrix();
                // this.SAM.position.x = this.dim.x * this.scale / 2;
                // this.SAM.position.y = this.dim.y * this.scale / 2;
                //               this.SAM.position.z = this.dim.z * this.scale;

                //  this.SAM.position.x = tx;
                // this.SAM.position.z = tz;

                //      this.SAM.position.x -= 0.0025;
            }
        }

        class Cannon {
            RELEASE_VELOCITY = 1;
            velocity = {
                x: 0,
                y: 0,
                z: 0,
            }
            acc = {
                x: 0,
                y: 0.005,
                z: 0
            }

            constructor(x, y, z, pitch, yaw, scene) {
                console.log("x: " + x + " y: " + y + " z: " + z + " yaw: " + yaw + " pitch: " + pitch);
                this.scene = scene;
                this.pitch = pitch;
                this.yaw = yaw;
                let geometry = new THREE.SphereGeometry(
                    0.05,//  radius
                    10,// widthSegments
                    10// heightSegments
                );
                let material = new THREE.MeshPhongMaterial({ color: 0xFF0000 });
                this.sphere = new THREE.Mesh(geometry, material);
                this.sphere.position.x = x;
                this.sphere.position.y = y;
                this.sphere.position.z = z;
                this.sphere.castShadow = true;
                this.velocity.z = this.RELEASE_VELOCITY * Math.cos(pitch) * Math.cos(yaw);
                this.velocity.x = this.RELEASE_VELOCITY * Math.sin(yaw);
                this.velocity.y = this.RELEASE_VELOCITY * Math.sin(-pitch);

                console.log("ZZ + " + this.getZ())
            }

            setX(x) {
                this.sphere.position.x = x;
            }

            setY(y) {
                this.sphere.position.y = y;
            }
            setZ(z) {
                this.sphere.position.z = z;
            }
            getX() {
                return this.sphere.position.x;
            }
            getY() {
                return this.sphere.position.y;
            }
            getZ() {
                return this.sphere.position.z;
            }

            getMesh() {
                return this.sphere;
            }

            move() {
                console.log("We are moving (x,y,z) (" + this.getX() + ", " + this.getY() + ", " + this.getZ() + ")");
                let xU = this.velocity.x; // Initial velocity along x-axis
                let yU = this.velocity.y; // Initial velocity along y-axis
                let zU = this.velocity.z;// Initial velocity along z-axis
                this.velocity.x = xU + this.acc.x // Final velocity along x-axis vx = ux + at 
                this.velocity.y = yU + Math.abs(this.acc.y); // Final velocity along y-axis vy = uy + g * t
                this.velocity.z = zU + this.acc.z; // Final velocity along z-axis vz = uz + g * t


                this.setX(this.getX() - xU + this.acc.x / 2); // Distance travelled per frame s = ux * t + ½a * t²
                this.setY(this.getY() - yU + this.acc.y / 2); // Distance travelled per frame s = uy * t + ½g * t²
                this.setZ(this.getZ() - zU - this.acc.z / 2); // Distance travelled per frame s = uy * t + ½g * t²
            }

            fire() {
                this.scene.add(this.sphere);
            }


        }

        class Ship {
            weapons = [];
            LEFT = 37;
            RIGHT = 39;
            DOWN = 40;
            UP = 38;
            FIRE_CANNON = 70;
            cameraOffset = {
                x: 0,
                y: 1,
                z: 3
            };
            MAX_VELOCITY = 0.1;
            velocity = {
                x: 0,
                y: 0,
                z: 0
            };
            acc = {
                x: 0,
                y: 0,
                z: 0.001
            }
            constructor() {
                this.sprite = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.05, 0.375), new THREE.MeshPhongMaterial({ color: 0x00ff00 }));
                this.sprite.position.y = 1;
                this.sprite.castShadow = true;
            }

            getX() {
                return this.sprite.position.x;
            }
            getY() {
                return this.sprite.position.y;
            }
            getZ() {
                return this.sprite.position.z;
            }

            setX(x) {
                return this.sprite.position.x = x;
            }
            setY(y) {
                return this.sprite.position.y = y;
            }
            setZ(z) {
                return this.sprite.position.z = z;
            }

            roll(angle) {
                this.sprite.rotation.z += angle;
            }
            yaw(angle) {
                this.sprite.rotation.y += angle;
            }
            pitch(angle) {
                this.sprite.rotation.x += angle;
            }


            handleKeyEvent(code, scene) {
                console.log("Key pressed working!!");
                if (code == this.RIGHT) {
                    this.sprite.rotation.y += toRad(-1);
                    this.sprite.rotation.z += toRad(-5);
                } else if (code == this.LEFT) {
                    this.sprite.rotation.y += toRad(1);
                    this.sprite.rotation.z += toRad(5);
                } else if (code == this.DOWN) {
                    this.sprite.rotation.x += toRad(1);

                } else if (code == this.UP) {
                    this.sprite.rotation.x += toRad(-1);
                } else if (code == this.FIRE_CANNON) {
                    let cannon = new Cannon(this.getX(), this.getY(), this.getZ(), this.sprite.rotation.x, this.sprite.rotation.z, scene);
                    this.weapons.push(cannon);
                    cannon.fire();
                    //      scene.add(cannon.getMesh());
                }
            }
            count = 0;
            move(camera, light) {

                this.weapons.forEach((weap) => {
                    weap.move();
                });

                let uz = this.velocity.z;
                let vz = uz + this.acc.z;


                let cosB = Math.cos(this.sprite.rotation.y);
                let sinB = Math.sin(this.sprite.rotation.y);

                let dz = Math.cos(this.sprite.rotation.y) * -vz * Math.cos(this.sprite.rotation.x);
                let dx = Math.sin(this.sprite.rotation.y) * -vz;
                let dy = Math.sin(this.sprite.rotation.x) * vz;

                this.velocity.z = Math.min(this.MAX_VELOCITY, -dz);


                let px = this.getX();
                let pz = this.getZ();

                this.setY(this.getY() + dy);
                this.setX(this.getX() * cosB + this.getZ() * -sinB + (px + dx) - px * cosB + pz * sinB);
                this.setZ(this.getX() * sinB + this.getZ() * cosB + (pz + dz) - pz * cosB - px * sinB);

                let delta = clock.getDelta();
                if (this.sprite.rotation.z !== 0) {
                    let diff = this.sprite.rotation.z;

                    this.sprite.rotation.z -= (diff * delta);
                }

                if (this.sprite.rotation.x !== 0) {
                    let diff = this.sprite.rotation.x;

                    this.sprite.rotation.x -= (diff * delta);
                }

                let camDiff = (camera.position.z - this.getZ() - this.cameraOffset.z);

                let translate = camDiff * delta;// + this.velocity.z * cosB + this.velocity.z * sinB;
                //     camera.position.z -= (translate);//this.getZ() + this.cameraOffset;


                let fx = -(camera.position.x - this.getX() - this.cameraOffset.x) * delta;
                let fz = -(camera.position.z - this.getZ() - this.cameraOffset.z) * delta;
                let xx = camera.position.x;
                let zz = camera.position.z;

                let ddx = (camera.position.x - this.getX());
                let ddz = (camera.position.z - this.getZ());
                //   sinB = Math.sin(Math.atan2(ddz, ddx));
                //    cosB = Math.cos(Math.atan2(ddz, ddx));          
                let xfx = xx * cosB + zz * -sinB + (ddx + fx) - (ddx) * cosB + (ddz) * sinB;
                let zfz = xx * sinB + zz * cosB + (ddz + fz) - (ddz) * cosB - (ddx) * sinB;

                camera.position.z -= (camera.position.z - this.getZ() - this.cameraOffset.z) * delta + this.velocity.z * cosB;
                camera.position.y -= (camera.position.y - this.getY() - this.cameraOffset.y) * delta;
                camera.position.x -= (camera.position.x - this.getX() - this.cameraOffset.x) * delta;

                light.position.z = camera.position.z + 2;
                //      light.lookAt(0,0,this.getZ() - 10);

                //           camera.position.copy(pos);
                //     camera.lookAt(look);
                // look.applyQuaternion(this.ship.target.Rotation);


            }
            getMesh() {
                return this.sprite;
            }
        }



        function initTHREEJS() {
            let scene = new THREE.Scene();

            let camera = new THREE.PerspectiveCamera(
                75, // field of view
                window.innerWidth / window.innerHeight, // aspect ratio
                0.1, // inner view
                1000 // outer view
            );
            camera.position.z = 5;
            camera.position.y = 2.5;
            camera.position.x = -1;

            //     camera.position.x = 0;

            let light = new THREE.SpotLight(
                0xFFFFFF// color
                , 1 // intensity
                , 500 // position
            );
            light.shadow.mapSize.width = 2024;
            light.shadow.mapSize.height = 2024;
            light.castShadow = true;
            light.position.set(0, 5, 5);
            //    light.lookAt(0, 0, 0);

            let renderer = new THREE.WebGLRenderer(
                { antialias: true }
            );
            renderer.setClearColor('#202020');
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            //       renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });
            let mouse = new THREE.Vector2();
            return {
                scene: scene,
                camera: camera,
                renderer: renderer,
                light: light,
            };
        }

        const { scene, camera, renderer, light } = initTHREEJS();
        var mouse = new THREE.Vector2();
        function onMouseClick(event) {
            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(scene.children, true);
            //      console.log(intersects);
            for (let i = 0; i < intersects.length; i++) {
                intersects[i].object.material.color.set(0xFF0000);
                this.t1 = new TimelineMax(.3);

                this.t1.to(this.mesh.position, 0.5, { x: 0.5, ease: Expo.easeOut });
                this.t1.to(this.mesh.rotation, 0.5, { z: Math.PI * 0.5, ease: Expo.easeOut });
            }
        }
        $(document.body).on('keydown', function (e) {

            ship.handleKeyEvent(e.which, scene);

        });

        const PLAIN_DIMEN = {
            x: 5,
            y: 5,
            z: 1000,
        };

        const geometry = new THREE.CylinderGeometry(2, 2, 1000, 48, 48, true, 0, 2 * Math.PI);
        const material = new THREE.MeshLambertMaterial({ color: 0x2F2F00, wireframe: true });
        const cylinder = new THREE.Mesh(geometry, material);
        cylinder.rotation.x = Math.PI / 2;




        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(PLAIN_DIMEN.x, PLAIN_DIMEN.z),
            new THREE.MeshPhongMaterial({ color: 0x1F1FFF0, side: THREE.DoubleSide })
        );
        plane.position.z -= PLAIN_DIMEN.z / 2;
        plane.castShadow = false;
        plane.receiveShadow = true;
        plane.rotation.x = Math.PI / 2;




        var toRad = (angle) => {
            return angle * Math.PI / 180;
        }

        var toDeg = (angle) => {
            return angle * 180 / Math.PI;
        }



        const ship = new Ship();

        const sam = new SAMLauncher(0, 0);

        //    ship.yaw(toRad(5));
        light.target = ship.getMesh();
        const helper = new THREE.CameraHelper(light.shadow.camera);

        scene.add(camera);
        scene.add(cylinder);
        scene.add(plane);

        scene.add(light);
        scene.add(helper);
        scene.add(ship.getMesh());
        scene.add(sam.getMesh());
        //   const controls = new THREE.OrbitControls(camera, renderer.domElement);
        var number = 45;

        const clock = new THREE.Clock();
        //clock.oldTime = 50;
        //clock.getDelta();

        var cameraOffset = {
            x: 1.7,
            y: 0.7,
            z: 1.7
        }
        var time = 0;
        const duration = Number.MAX_VALUE - Number.MAX_VALUE + 1.2; // 2 seconds maneurverA
        var angle = 0;


        var repeatMe = function () {
            number++;

            requestAnimationFrame(repeatMe);



            //     camera.position.y = ball.getY() + .2;// + 0.2;// + 1;
            //      camera.lookAt(0, 0, -100);


            //        clock.getDelta();
            //        time = clock.elapsedTime;
            //     ship.move(camera, light)

            //  controls.update();
            //           sam.getMesh().rotation.y += toRad(0.5);
            angle += toRad(0.5);
            sam.rotateY(angle);

            renderer.render(scene, camera);

        }
        repeatMe();

    </script>
</body>

</html>