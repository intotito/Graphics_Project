<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Night Raider</title>
    <link rel="stylesheet" href="./style/style.css">

</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.5/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
    <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script> -->

    <script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>
    <!-- <script src="OrbitControls.js"></script> -->

    <canvas id="img-back"></canvas>
    <div id="main-panel">
        <div id="title-container">
            <span id="main-title-text">Night Raider</span>
        </div>
        <div id="button-container">
            <Button id="start-button">Start</Button>
        </div>
        <div id="button-container">

            <Button id="high-button">High Scores</Button>
        </div>
    </div>
    <div id="game-over-panel">
        <div id="title-container">
            <span id="main-title-text">Night Raider</span>
        </div>
        <div id="title-container">
            <span id="title-text">Game Over</span>
        </div>
        <div id="title-container">
            <span id="score-title-text">Score: </span>
        </div>
        <div id="button-container">
            <Button id="restart-button">Restart</Button>
        </div>
        <div id="button-container">

            <Button id="high-button">High Scores</Button>
        </div>
    </div>

    <div id="score-card">+2000</div>

    <div id="paused-panel">
        <div id="title-container">
            <span id="main-title-text">Night Raider</span>
        </div>
        <div id="button-container">
            <Button id="resume-button">Resume</Button>
        </div>
        <div id="button-container">

            <Button id="restart-button">Restart</Button>
        </div>
    </div>
    <div id="count-container">
        <div id="count-down">5</div>
    </div>

    <div id="game-info">
        <div class="info-row">
            <div class="divider"></div>
        </div>
        <div class="info-row">
            <div class="player-name">Live:</div>
            <div id="img_container">
                <img id="img_live1" src="./images/live_.svg">

                <img id="img_live2" src="./images/live_.svg">

                <img id="img_live3" src="./images/live_.svg">
            </div>
        </div>
        <div class="info-row">
            <div class="divider"></div>
        </div>
        <div class="info-row">
            <div class="player-name">Health:</div>
            <div id="health-bar">
                <div id="health"></div>
            </div>
        </div>
        <div class="info-row">
            <div class="divider"></div>
        </div>
        <div class="info-row">
            <div class="player-name">Score</div>
            <div id="score">38200
            </div>
        </div>
        <div class="info-row">
            <div class="divider"></div>
        </div>
    </div>





    <script type="text/javascript">
        var startButton = document.getElementById('start-button');
        var resumeButton = document.getElementById('resume-button');
        var restartButton = document.getElementById('restart-button');
        var highsButton = document.getElementById('high-button');


        startButton.addEventListener('click', (event) => {
            document.getElementById('main-panel').style.display = 'none';
            let healthElement = document.getElementById('health');
            healthElement.style.width = '100%';
            paused = false;
        })
        resumeButton.addEventListener("click", (event) => {
            paused = false;
            document.getElementById('paused-panel').style.display = 'none';
        });
        restartButton.addEventListener("click", (event) => {
            paused = false;
            document.location.reload();
        });


        const MISSILES = [];
        const CANNONS = [];
        var SAMS = [];
        const MISSILE_VELOCITY = 0.65;
        const SHIP_VELOCITY = 0.35;
        const GRAVITY = -0.001;
        const CANNON_VELOCITY = 2;
        class SAMLauncher {
            TELEMENTRIES = [
                {
                    INDEX: 1, // Determines if target is hit during boost or re-entry  0 - Boost phase, 1 - Re-entry phase
                    route: 1, // Determines if terget is hit from east or west
                    attackAngle: toRad(45), // Attack angle along the route
                    engageAngle: toRad(20) // Attack angle of the missile
                },
                {
                    INDEX: 1, // Determines if target is hit during boost or re-entry  0 - Boost phase, 1 - Re-entry phase
                    route: 0, // Determines if terget is hit from east or west
                    attackAngle: toRad(15), // Attack angle along the route
                    engageAngle: toRad(15) // Attack angle of the missile
                },
                {
                    INDEX: 0, // Determines if target is hit during boost or re-entry  0 - Boost phase, 1 - Re-entry phase
                    route: 0, // Determines if terget is hit from east or west
                    attackAngle: toRad(5), // Attack angle along the route
                    engageAngle: toRad(15) // Attack angle of the missile
                },
                {
                    INDEX: 0, // Determines if target is hit during boost or re-entry  0 - Boost phase, 1 - Re-entry phase
                    route: 1, // Determines if terget is hit from east or west
                    attackAngle: toRad(2.5), // Attack angle along the route
                    engageAngle: toRad(30) // Attack angle of the missile
                },
                {
                    INDEX: 0, // Determines if target is hit during boost or re-entry  0 - Boost phase, 1 - Re-entry phase
                    route: 1, // Determines if terget is hit from east or west
                    attackAngle: toRad(2.5), // Attack angle along the route
                    engageAngle: toRad(35) // Attack angle of the missile
                }
            ];

            attackAngle = toRad(4); // change here ** Describes the radius of the circular path the missile takes to its target
            count = 0;
            angle = 0;
            missiles = [];
            IDLE = 0;
            ENGAGING = 1;
            RETRACTING = 2;
            READY = 3;
            WAITING = 4;
            DESTRUCTING = 5;
            state = this.IDLE;
            dist = 0;
            dim = {
                x: 1,
                y: 0.32,
                z: 0.5
            }
            trans = {
                x: -this.dim.x,
                y: 0,//this.dim.y / 2,
                z: 0
            };
            scale = {
                x: 2.5,
                y: 2.5,
                z: 2.5
            };

            getX() {
                return this.SAM.position.x;
            }
            getY() {
                return this.SAM.position.y;
            }
            getZ() {
                return this.SAM.position.z;
            }
            setX(x) {
                this.SAM.position.x = x;
                for (let i = 0; i < this.missiles.length; i++) {
                    if (i >= this.count) {
                        this.missiles[i].getMesh().position.x = x;
                        //unfired move
                    } else {
                        // fired ignore
                    }
                }
            }
            setY(y) {
                this.SAM.position.y = y;
                for (let i = 0; i < 4; i++) {
                    if (i >= this.count) {
                        this.missiles[i].getMesh().position.y = y;
                        //unfired move
                    } else {
                        // fired ignore
                    }
                }
            }
            setZ(z) {
                this.SAM.position.z = z;
                for (let i = 0; i < 4; i++) {
                    if (i >= this.count) {
                        // console.log("HOwm any times " + i);
                        this.missiles[i].setZ(z - this.dim.x / 2);
                        //unfired move
                    } else {
                        // fired ignore
                    }
                }
            }
            explode() {
                this.state = this.DESTRUCTING;
                let velocity = [
                    new THREE.Vector3(-0.1, 0.1, 0.1),
                    new THREE.Vector3(-0.1, 0, 0),
                    new THREE.Vector3(0.1, 0, 0.1),
                    new THREE.Vector3(0.1, 0.1, -0.1)
                ];
                let reaction = [
                    new THREE.Vector3(-1, 0.5, 0.25),
                    new THREE.Vector3(-1, 0, 0),
                    new THREE.Vector3(0.5, 0, 0.3),
                    new THREE.Vector3(1, 1, -1)
                ];
                this.getMesh().children.forEach((c, i) => {
                    c.finalPosition = c.position.clone().add(reaction[i]);
                    //      c.reaction = reaction[i];
                    c.velocity = velocity[i];
                });
            }

            getSign(value) {
                return value / Math.abs(value);
            }
            exploding() {

                this.getMesh().children.forEach((c, index) => {
                    // console.log(c.name);
                    let unfired = this.missiles.filter((m, i) => (i >= this.count && index == 3));
                    if (c.position.x * this.getSign(c.velocity.x) < c.finalPosition.x * this.getSign(c.velocity.x)) {
                        c.position.x += c.velocity.x;
                        unfired.forEach((m) => {
                            m.vehicle.position.x += c.velocity.x;
                            m.vehicle.rotation.z += 0.01;
                        });
                        c.rotation.z += 0.01;
                    } if (c.position.y >= 0) {
                        c.position.y += (c.velocity.y += -0.01);
                        unfired.forEach((m) => {
                            m.vehicle.position.y += (c.velocity.y);
                        })
                    } if (c.position.z * this.getSign(c.velocity.z) < c.finalPosition.z * this.getSign(c.velocity.z)) {
                        c.position.z += c.velocity.z;
                        unfired.forEach((m) => {
                            m.vehicle.position.z += -c.velocity.z;
                        })
                    }
                });
            }
            constructor(x, z) {
                this.engageAngle = toRad(45); // change here
                this.state = 0;
                this.dim.x *= this.scale.x;
                this.dim.y *= this.scale.y;
                this.dim.z *= this.scale.z;
                this.trans.x = -this.dim.x / 2;
                this.SAM = new THREE.Group();
                let shape = new THREE.Shape();
                shape.moveTo(0 + this.trans.x, 0 + this.trans.y);
                shape.lineTo(0 + this.trans.x, this.dim.y / 2 + this.trans.y);
                shape.lineTo(0.6 * this.dim.x + this.trans.x, this.dim.y / 2 + this.trans.y);
                shape.lineTo(0.6 * this.dim.x + this.trans.x, this.dim.y + this.trans.y);
                shape.lineTo(0.85 * this.dim.x + this.trans.x, this.dim.y + this.trans.y);
                shape.lineTo(this.dim.x + this.trans.x, this.dim.y * 0.75 + this.trans.y);
                shape.lineTo(this.dim.x + this.trans.x, this.dim.y * 0.15 + this.trans.y);
                shape.lineTo(this.dim.x * 0.95 + this.trans.x, 0 + this.trans.y);
                shape.lineTo(this.dim.x * 0.9 + this.trans.x, 0 + this.trans.y);
                shape.arc(-this.dim.x * 0.15 / 2, 0, this.dim.x * 0.15 / 2, 0, Math.PI, false);
                shape.lineTo(this.dim.x * 0.2 + this.trans.x, 0 + this.trans.y);
                shape.arc(-this.dim.x * 0.15 / 2, 0, this.dim.x * 0.15 / 2, 0, Math.PI, false);
                shape.lineTo(0 + this.trans.x, 0 + this.trans.y);
                let extrudeSettings = {
                    steps: 1,
                    depth: this.dim.z,
                    bevelEnabled: true,
                    bevelThickness: 0,
                    bevelSize: 0,
                    bevelSegment: 2
                };
                let geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings)
                // console.log(-this.dim.z / 2);
                geometry.translate(0, 0, this.dim.z / -2);
                this.mesh = new THREE.Mesh(geometry,
                    new THREE.MeshPhongMaterial({ color: 0x00ff00 }));
                //      this.mesh.name = "Chasis";


                let shape1 = new THREE.Shape();
                shape1.moveTo(this.dim.x * 0.2 + this.trans.x, 0 + this.trans.y);
                shape1.arc(-this.dim.x * 0.15 / 2, 0, this.dim.x * 0.15 / 2, 0, 2 * Math.PI, false);

                let extrudeSettings1 = {
                    steps: 2,
                    depth: this.dim.z * 1.1,
                    bevelEnabled: true,
                    bevelThickness: 0,
                    bevelSegment: 2,
                    bevelSize: 0
                };

                this.mesh1 = new THREE.Mesh(new THREE.ExtrudeGeometry(shape1, extrudeSettings1),
                    new THREE.MeshPhongMaterial({ color: 0x2F2F2F }));
                this.mesh1.geometry.translate(0, 0, -this.dim.z * 1.1 / 2);
                // this.mesh1.name = "Front Tyre";
                this.mesh2 = new THREE.Mesh(new THREE.ExtrudeGeometry(shape1, extrudeSettings1),
                    new THREE.MeshPhongMaterial({ color: 0x2F2F2F }));
                // this.mesh2.name = "Back Tyre";
                // console.log(this.mesh2.geometry);
                this.mesh2.geometry.translate(0.7 * this.dim.x, 0, -this.dim.z * 1.1 / 2);



                let shape2 = new THREE.Shape();
                let h = this.dim.y * 0.25;
                let w = this.dim.z;
                let tx = -w / 2;
                let ty = 0;// this.dim.y / 2;// -h / 2;
                let r = (h * 0.75) / 2;



                shape2.moveTo(tx + 0, ty + 0);
                shape2.lineTo(tx + 0, ty + h);
                shape2.lineTo(tx + w, ty + h);
                shape2.lineTo(tx + w, ty + 0);
                shape2.lineTo(tx + 0, ty + 0);

                for (let i = 0; i < 4; i++) {
                    let s = new THREE.Shape();
                    s.moveTo(tx + (w / 4) * i + ((w / 4) - 2 * r) / 2, ty + h / 2);
                    s.arc(r, 0, r, 0, 2 * Math.PI, false);
                    shape2.holes.push(s);
                }


                // shape2.moveTo(this.dim.x * 0.2 + this.trans.x, 0 + this.trans.y);
                // shape2.arc(-this.dim.x * 0.15 / 2, 0, this.dim.x * 0.15 / 2, 0, Math.PI, false);

                let extrudeSettings2 = {
                    steps: 2,
                    depth: this.dim.x * 0.6,
                    bevelEnabled: true,
                    bevelThickness: 0,
                    bevelSegment: 2,
                    bevelSize: 0
                };
                this.mesh3 = new THREE.Mesh(new THREE.ExtrudeGeometry(shape2, extrudeSettings2),
                    new THREE.MeshPhongMaterial({ color: 0x024F02 }));
                //      this.mesh3.geometry.translate(0, this.dim.y * 0.5 + h / 2, -this.dim.x * 0.6 / 2);

                //    this.mesh3.rotation.y = Math.PI / 2;
                //   this.mesh3.rotation.x = -Math.PI / 4;
                this.mesh3.rotateY(Math.PI / 2);
                //     this.mesh3.geometry.translate(0, 0, -0.2 * this.dim.x);
                this.mesh3.position.x = -this.dim.x / 2;
                this.mesh3.position.y = this.dim.y / 2;
                // this.mesh3.name = "Launching Casing";
                // console.log(this.mesh3.geometry);



                //         this.mesh3.geometry.translate(0.7 * this.dim.x, 0, -this.dim.z * 1.1 / 2);
                //        this.mesh3.position.y = this.dim.y / 2;

                this.SAM.add(this.mesh, this.mesh1, this.mesh2, this.mesh3);

                this.SAM.rotation.y = 3 * Math.PI / 2;
                this.SAM.position.x = x;
                this.SAM.position.z = z;
                this.SAM.position.y = this.dim.x * 0.15 / 2;
                for (let index = 0; index < 4; index++) {
                    const e = new Missile(this.dim, this.scale, index);
                    this.missiles.push(e);
                }

            }

            getMesh() {
                return this.SAM;
            }

            addMissiles(scene) {
                this.missiles.forEach((m) => {
                    scene.add(m.getMesh());
                });
                // console.log("Missiles added");
            }



            move() {

                let telementry = this.TELEMENTRIES[this.count];


                let ymax = ship.getY();
                let theta = Math.asin((2 * ymax * -GRAVITY) / MISSILE_VELOCITY);
                //       let aaa = telementry.engageAngle;//  this.engageAngle;
                let v = MISSILE_VELOCITY * Math.sin(telementry.engageAngle);
                let vx = MISSILE_VELOCITY * Math.cos(telementry.engageAngle);
                let g = GRAVITY;
                let y = ship.getY();
                let t1 = -(v / g) + (Math.sqrt(v * v + 2 * g * y)) / g;
                let t2 = -(v / g) - (Math.sqrt(v * v + 2 * g * y)) / g;

                let range1 = vx * t1; // Hit 
                let range2 = vx * t2;


                let INDEX = telementry.INDEX; // WHETHER TO ATTACK 0 - AT BOOST, 1 - RE-ENTRY PHASE



                let TIME = [
                    -(v / g) + (Math.sqrt(v * v + 2 * g * y)) / g,
                    -(v / g) - (Math.sqrt(v * v + 2 * g * y)) / g
                ];
                let RANGE = [
                    vx * TIME[0],
                    vx * TIME[1]
                ];
                let BACK_OFF = [
                    TIME[0] * SHIP_VELOCITY,
                    TIME[1] * SHIP_VELOCITY
                ];
                let DIFFERENCE = [
                    ship.getZ() - RANGE[0],
                    ship.getZ() - RANGE[1]
                ];

                let shipBackoff = t1 * SHIP_VELOCITY;//-ship.velocity.z; ********** should multiply by orientation of ship

                let TIME_TO_TARGET = DIFFERENCE[INDEX] / -ship.velocity.z;


                let CHECK_MARK = this.getZ() + RANGE[INDEX] + BACK_OFF[INDEX];


                let target = {
                    attackAngle: telementry.attackAngle,//  this.attackAngle, // don't change here
                    route: telementry.route, // Circular route the missile will take
                    x: ship.getX(),
                    y: ship.getY(),
                    z: this.getZ() + RANGE[INDEX], //range1,
                    angularVelocity: telementry.attackAngle / TIME[INDEX], //t1,
                    range: RANGE,//[range1, range2],
                    time: TIME //[t1, t2]     
                }
                //console.log(target)

                let difference = Math.sqrt((ship.getY() - this.SAM.position.y) ** 2 + (ship.getZ() - this.SAM.position.z) ** 2);

                if (this.state === this.IDLE && this.count < 4) {


                    if (ship.getZ() < (CHECK_MARK + 100)) {

                        this.engage();
                    }
                } else if (this.state === this.ENGAGING && this.count < 4) {

                    this.engaging();
                } else if (this.state === this.RETRACTING) {
                    this.retracting();
                } else if (this.state == this.READY && this.count < 4) {

                    let ERROR = INDEX == 0 ? -4 : 5;
                    if (ship.getZ() < CHECK_MARK + ERROR) {
                        // console.log("TTest", " Shoot when ->", "CheckMark: ", CHECK_MARK.toFixed(2), "Ship Location: ", ship.getZ().toFixed(2),
                        //     "Ship Ceiling: ", ship.getY().toFixed(2), "Ship Orientation: ", toDeg(ship.getMesh().rotation.y).toFixed(2), target, "Angle: ", toDeg(this.missiles[this.count].vehicle.rotation.x));
                        this.fire(target);

                    }
                } else if (this.state === this.DESTRUCTING) {
                    this.exploding();
                }

                this.missiles.forEach((m) => {
                    m.move();
                })
                if ((this.getZ() - ship.getZ()) > 20) {
                    // console.log("Remover", "Attempting to remove myself");
                    for (let i = 0; i < SAMS.length; i++) {
                        if (SAMS[i] == this) {
                            SAMS.splice(i, 1);
                            for (let j = 0; j < this.missiles.length; j++) {
                                scene.remove(this.missiles[j].getMesh());
                            }
                            scene.remove(this.getMesh());
                            // console.log("Remover", "I just removed myself from the scene"); 0
                            break;
                        }
                    }
                }

            }

            fire(target) {

                if (this.count < 4) {
                    // console.log("Did i fire?");
                    this.missiles[this.count].fire(target);
                    if (this.count !== 3) {
                        this.state = this.IDLE;
                    }
                }
                if (this.count == 3) {
                    this.state = this.RETRACTING;
                }
                ++this.count;
            }

            engage() {
                /*                let dy = ship.getY() - this.getY();
                               let dx = ship.getX() - this.getX();
                               let dz = ship.getZ() - this.getZ();
                               // this.engageAngle = Math.atan2(dy, dz) * 5;
                               let ymax = ship.getY();
                               let theta = Math.asin(Math.sqrt(2 * ymax * -GRAVITY) / MISSILE_VELOCITY);
                               console.log("Test", " theta: " + toDeg(theta) + " Ship y: " + ymax + " EngageAngle " + toDeg(this.engageAngle));
                               console.log("EngageX at: " + toDeg(Math.atan2(dy, dz))) */
                if (this.count > 0) {
                    if (this.TELEMENTRIES[this.count].engageAngle > this.TELEMENTRIES[this.count - 1].engageAngle) {
                        this.shift = 1;
                    } else {
                        this.shift = -1;
                    }
                }
                this.state = this.ENGAGING;
            }
            magic() {
                // this.engageAngle = toRad(20);
                // this.shift = -1;
                this.count++;
                if (this.TELEMENTRIES[this.count].engageAngle > this.TELEMENTRIES[this.count - 1].engageAngle) {
                    this.shift = 1;
                } else {
                    this.shift = -1;
                }
                this.engage();

                // console.log("Magic", " count: ", this.count, " Shift: ", this.shift);
                this.engage();
                if (this.count == 3) {
                    this.state = this.RETRACTING;
                }
            }
            retracting() {
                if (toDeg(this.angle) < 0) {
                    this.angle += toRad(.1);
                    this.mesh3.rotateX(toRad(.1));

                } else {
                    this.angle = 0;
                    this.mesh3.rotateX(-this.angle);
                    this.state = this.IDLE;
                }
            }
            shift = 1;
            engaging() {
                let telementry = this.TELEMENTRIES[this.count];
                //           let shift = 1; // 1 - increasing, -1 - decreasing
                //         console.log("Engaging at" + toDeg(telementry.engageAngle), "this.angle: ", toDeg(this.angle).toFixed(2));
                //        console.log("Engaging", "(", toDeg(this.angle).toFixed(0), " * ", this.shift, ") > -(", toDeg(telementry.engageAngle), " * ", this.shift, ")");
                if ((this.angle * this.shift) > -(telementry.engageAngle * this.shift)) {

                    this.angle -= toRad(this.shift / 2);
                    this.mesh3.rotateX(toRad(-this.shift / 2));
                    for (let i = 0; i < this.missiles.length; i++) {
                        if (i >= this.count) {
                            //                       console.log("TTest", this.angle);
                            this.missiles[i].getMesh().rotation.x = this.angle;//+= toRad(-this.shift/4);
                        }
                    }
                } else {
                    this.missiles[this.count].getMesh().rotation.x = -Number(this.TELEMENTRIES[this.count].engageAngle);
                    this.state = this.READY;
                    // console.log("WHo's calling me")
                }
            }
        }
        class Cannon {
            RELEASE_VELOCITY = CANNON_VELOCITY;
            velocity = {
                x: 0,
                y: 0,
                z: 0,
            }
            acc = {
                x: 0,
                y: 0.005,
                z: 0
            }

            constructor(x, y, z, pitch, yaw, scene) {
                // console.log("x: " + x + " y: " + y + " z: " + z + " yaw: " + yaw + " pitch: " + pitch);
                this.scene = scene;
                this.pitch = pitch;
                this.yaw = yaw;
                let geometry = new THREE.SphereGeometry(
                    0.05,//  radius
                    16,// widthSegments
                    16// heightSegments
                );
                let material = new THREE.MeshPhongMaterial({ color: 0xFF0000 });
                this.sphere = new THREE.Mesh(geometry, material);
                this.sphere.position.x = x;
                this.sphere.position.y = y;
                this.sphere.position.z = z;
                // this.sphere.castShadow = true;
                this.velocity.z = this.RELEASE_VELOCITY * Math.cos(pitch) * Math.cos(yaw);
                this.velocity.x = this.RELEASE_VELOCITY * Math.sin(yaw);
                this.velocity.y = this.RELEASE_VELOCITY * Math.sin(-pitch);

                // console.log("ZZ + " + this.getZ())
            }

            setX(x) {
                this.sphere.position.x = x;
            }

            setY(y) {
                this.sphere.position.y = y;
            }
            setZ(z) {
                this.sphere.position.z = z;
            }
            getX() {
                return this.sphere.position.x;
            }
            getY() {
                return this.sphere.position.y;
            }
            getZ() {
                return this.sphere.position.z;
            }

            getMesh() {
                return this.sphere;
            }

            move() {
                // console.log("We are moving (x,y,z) (" + this.getX() + ", " + this.getY() + ", " + this.getZ() + ")");
                let xU = this.velocity.x; // Initial velocity along x-axis
                let yU = this.velocity.y; // Initial velocity along y-axis
                let zU = this.velocity.z;// Initial velocity along z-axis
                this.velocity.x = xU + this.acc.x // Final velocity along x-axis vx = ux + at 
                this.velocity.y = yU + Math.abs(this.acc.y); // Final velocity along y-axis vy = uy + g * t
                this.velocity.z = zU + this.acc.z; // Final velocity along z-axis vz = uz + g * t


                this.setX(this.getX() - xU + this.acc.x / 2); // Distance travelled per frame s = ux * t + ½a * t²
                this.setY(this.getY() - yU + this.acc.y / 2); // Distance travelled per frame s = uy * t + ½g * t²
                this.setZ(this.getZ() - zU - this.acc.z / 2); // Distance travelled per frame s = uy * t + ½g * t²
                if ((this.getY()) < 0) {
                    // console.log("Remover", "Cannon Attempting to remove myself");
                    for (let i = 0; i < ship.weapons.length; i++) {
                        if (ship.weapons[i] == this) {
                            ship.weapons.splice(i, 1);
                            scene.remove(this.getMesh());
                            // console.log("Remover", "Cannon I just removed myself from the scene"); 0
                            break;
                        }
                    }
                }
                // COLLISSION DETTECTION
                SAMS.filter((s) => {
                    if (this.getZ() - s.getZ() < 100) {  // Check only with Sams within 20 unit distance
                        return true;
                    }
                    return false;
                }).forEach((s) => {
                    let samBB = new THREE.Box3().setFromObject(s.getMesh());
                    let cannonBB = new THREE.Box3().setFromObject(this.getMesh());
                    if (samBB.intersectsBox(cannonBB)) {
                        if (s.state !== s.DESTRUCTING) {

                            let hitRange = (this.start - s.getZ());
                            let hitScore = 2500 * (1 + hitRange / 50);
                            score += hitScore;

                            const scoreElement = document.getElementById('score-card');
                            scoreElement.innerHTML = '+' + hitScore.toFixed(0);
                            scoreElement.style.display = 'flex';
                            window.setTimeout(() => {
                                scoreElement.style.display = 'none';
                            }, 1000);
                        }
                        s.explode();
                    }
                });

            }

            fire() {
                this.scene.add(this.sphere);
                this.start = this.getZ();
            }


        }

        class Missile {
            start = 0;
            target = {
                x: 0,
                y: 0,
                z: 0,
                route: 0
            };
            IDLE = 0;
            FLYIING = 1;
            EXPLODING = 2;
            state = this.IDLE;
            target_Angle = 0;
            timer = new THREE.Clock();
            radius = 0;

            gainAngle = 0;
            angVel = 0;
            angR = 0;
            angQ = 0;
            center = {
                x: 0,
                z: 0
            }

            velocity = {
                x: 0,
                y: 0,
                z: 0
            }
            acc = {
                x: 0,
                y: GRAVITY,
                z: 0
            }

            shiftx = 0;

            constructor(dim, scale, i) {
                this.dim = dim;
                this.scale = scale;
                let h = this.dim.y * 0.25;
                let w = this.dim.z;
                let tx = -w / 2;
                let ty = 0;// this.dim.y / 2;// -h / 2;
                let r = (h * 0.75) / 2;
                //           for (let i = 0; i < 4; i++) {
                let s = new THREE.Shape();
                this.shiftx = (i * -w / 4) + (3 * w / 8);
                // console.log("AAA i: ", i, " shiftx: ", this.shiftx);
                s.moveTo(tx + (w / 4) * i + ((w / 4) - 2 * r) / 2, ty + h / 2);
                s.arc(r, 0, r, 0, 2 * Math.PI, false);
                //  shape2.holes.push(s);
                //          }
                let extrudeSettings2 = {
                    steps: 2,
                    depth: this.dim.x * 0.6,
                    bevelEnabled: true,
                    bevelThickness: 0,
                    bevelSegment: 2,
                    bevelSize: 0
                };
                this.vehicle = new THREE.Mesh(new THREE.ExtrudeGeometry(s, extrudeSettings2),
                    new THREE.MeshPhongMaterial({ color: 0xFEFEFE }));


                this.vehicle.position.z -= dim.x / 2;
                //         this.vehicle.rotateY(1 * Math.PI / 2);
                // this.vehicle.position.x = -this.dim.z / 2;
                this.vehicle.position.y = this.dim.y / 2 + this.dim.x * 0.15 / 2;


            }

            getX() {
                // return this.status == this.FLYING ? this.vehicle.position.x + this.shiftx : this.vehicle.position.x;
                return this.vehicle.position.x - this.shiftx;
            }
            getY() {
                return this.vehicle.position.y;
            }
            getZ() {
                return this.vehicle.position.z;
            }
            setX(x) {
                this.vehicle.position.x = x;
            }
            setY(y) {
                this.vehicle.position.y = y;
            }
            setZ(z) {
                this.vehicle.position.z = z;
            }

            getMesh() {
                return this.vehicle;
            }
            fire(target) {
                this.start = this.getZ();
                let p1 = { x: this.getX(), z: this.getZ() }
                let p2 = { x: target.x, z: target.z }
                if (p2.x >= p1.x) {
                    target.route = 1;
                } else {
                    target.route = 0;
                }
                this.target = target;
                // console.log("XTC", target);
                // console.log("XTC p1:", p1);
                // console.log("XTC p2:", p2);

                let dx = p2.x - p1.x;
                let dz = p2.z - p1.z;
                let d = Math.sqrt(dx * dx + dz * dz);

                let m = Math.atan2(dx, dz);
                // let w = Math.PI / 2 - m;
                let theta = target.attackAngle;
                let a = (Math.PI - theta) / 2;

                let R = [a + m + Math.PI, a + m];
                let Q = Math.PI - (theta + R[target.route]);

                let r = d * Math.sin(a) / Math.sin(theta);

                let h0 = r * Math.sin(R[target.route]);
                let w0 = r * Math.cos(R[target.route]);

                let h1 = r * Math.sin(Q);
                let w1 = r * Math.cos(Q);



                if (target.route === 1) {
                    this.center.x = p1.x + h0;
                    this.center.z = p1.z + w0;
                    //          R = Math.PI + R;
                }
                else if (target.route === 0) {
                    this.center.x = p1.x + h1;
                    this.center.z = p1.z - w1;
                }

                this.angR = R[target.route];//-(R - Math.PI / 2);
                this.angQ = Math.PI - (theta + R[target.route]);
                this.radius = r;
                this.angVel = target.angularVelocity;

                this.state = this.FLYIING;
                // console.log("Check: " + toDeg(Math.PI / 2 + this.vehicle.rotation.x));
                let vel = MISSILE_VELOCITY;

                this.velocity.y = Math.cos(Math.PI / 2 + this.vehicle.rotation.x) * vel;
                this.velocity.z = Math.sin(Math.PI / 2 + this.vehicle.rotation.x) * vel;
                this.velocity.x = Math.sin(this.vehicle.rotation.y) * vel;


                // console.log("MissileFired");
            }
            move() {
                if (this.state === this.IDLE) {
                    //         console.log("IDLE MISSILE");
                } else if (this.state === this.FLYIING) {
                    let ux = this.velocity.x;
                    let uy = this.velocity.y;
                    let uz = this.velocity.z;

                    let vz = uz + this.acc.z;
                    let vx = Math.sin(this.vehicle.rotation.y) * uz + this.acc.x;
                    let vy = uy + this.acc.y;

                    let x = this.getX() + (ux + vx) / 2;
                    let z = this.getZ() + (uz + vz) / 2;
                    let y = this.getY() + (uy + vy) / 2;

                    let dx = ship.getX() - this.getX();
                    let dz = ship.getZ() - this.getZ();


                    let angX = Math.atan2(vy, vz);
                    //                   let angY = Math.atan2(dx, dz);
                    // console.log("angR: " + toDeg(this.angR))
                    let angY = this.target_Angle / (dz / (vz - ship.velocity.z));
                    //        missile.position.x = path.position.x + r * Math.cos(angg1 + angle);
                    let xx = 0, zz = 0;
                    if (this.target.route === 1) {
                        xx = this.center.x - this.radius * Math.sin(this.angR + this.gainAngle);
                        zz = this.center.z - this.radius * Math.cos(this.angR + this.gainAngle);
                    }
                    else if (this.target.route === 0) {
                        xx = this.center.x - this.radius * Math.sin(this.angQ + this.gainAngle);
                        zz = this.center.z + this.radius * Math.cos(this.angQ + this.gainAngle);
                    }
                    //       missile.rotation.y = angg1 - angle;
                    //  console.log("Recheck O(x,z): (" + this.center.x + ", " + this.center.z + ")");
                    //               console.log(`Compare (xR - xL) - (${xx} - ${x}), (zR - zL) - (${zz} - ${z})`);
                    this.velocity.x = vx;
                    this.velocity.y = vy;
                    this.velocity.z = vz;
                    this.setX(xx);
                    this.setY(y);
                    this.setZ(zz);
                    // console.log("Result", "z = " + this.getZ());
                    this.vehicle.rotation.x = -angX;
                    if (this.target.route === 1) {
                        this.vehicle.rotation.y = this.angR + Math.PI / 2 + this.gainAngle;
                    } else if (this.target.route === 0) {
                        this.vehicle.rotation.y = -this.angQ + Math.PI / 2 - this.gainAngle;
                    }
                    if (Math.abs(this.vehicle.rotation.y) < Math.abs(this.target_Angle)) {
                        //               this.vehicle.rotation.y += angY;
                    }
                    if (y <= 0) {
                        this.state = this.EXPLODING;
                    }
                    this.gainAngle += this.angVel;

                    // COLLISSION DETECTION
                    let missileBB = new THREE.Box3().setFromObject(this.getMesh());
                    let shipBB = new THREE.Box3().setFromObject(ship.getMesh());
                    if (ship.state === ship.STATE_ALIVE && missileBB.intersectsBox(shipBB)) {
                        ship.rock();
                        let hitRange = (ship.getZ() - this.start);
                        let hitScore = 8 * (1 + hitRange / 350);
                        health -= hitScore;
                        if (health < 0) {
                            health = 0;
                            ship.die();
                        }
                        let healthElement = document.getElementById('health');
                        healthElement.style.width = health + '%';
                        console.log("health1111", healthElement, "Health", health, "Hitscore", hitScore, "Hit range", hitRange);
                    }

                } else if (this.state === this.EXPLODING) {
                    // console.log("EXPLODING MISSILE");
                }

            }
        }

        class Ship {
            live = 3;
            STATE_ALIVE = 0;
            STATE_DYING = 1;
            STATE_DEAD = 2;
            STATE_RESURECTING;
            state = this.STATE_ALIVE;
            weapons = [];
            LEFT = 37;
            RIGHT = 39;
            DOWN = 40;
            UP = 38;
            FIRE_CANNON = 70;
            dim = {
                x: 68,
                y: 100,
                z: 1
            };
            trans = {
                x: 0,
                y: 0,
                z: 0
            }
            scale = {
                x: 1 / 100,
                y: 1 / 100,
                z: 1 / 100
            }
            cameraOffset = {
                x: 0,
                y: 1,
                z: 3
            };
            MAX_VELOCITY = SHIP_VELOCITY;
            velocity = {
                x: 0,
                y: 0,
                z: 0
            };
            acc = {
                x: 0,
                y: 0.000,
                z: 0.0001
            }
            constructor() {
                this.dim.x *= this.scale.x;
                this.dim.y *= this.scale.y;
                this.dim.z *= this.scale.z;

                this.trans.x = -this.dim.x / 2;
                this.trans.y = -this.dim.y / 2;

                let radius = this.dim.x / 2 - (33.3 * this.scale.x);
                let height = 17.89 * this.scale.y;
                // console.log("Radius = " + radius + " Height = " + height + " dim.x = " + this.dim.x);

                let noseGeo = new THREE.ConeGeometry(radius, height, 32);
                let material = new THREE.MeshPhongMaterial({ color: 0x002200 });
                this.nose = new THREE.Mesh(noseGeo, material);
                noseGeo.translate(0, this.trans.y + this.dim.y - height / 2, 0);

                let cockHeight = 11.32 * this.scale.y;
                let cockpitGeo = new THREE.CylinderGeometry(radius, (this.dim.x / 2 - 25.41 * this.scale.x) / 2, cockHeight);
                this.cockpit = new THREE.Mesh(cockpitGeo, material);
                cockpitGeo.translate(0, this.trans.y + this.dim.y - height - cockHeight / 2, 0);

                /* 
                                let intakeHeight = 22.71 * this.scale.y;
                                let intakeGeo = new THREE.BoxGeometry(this.dim.x / 2 - 25.41 * this.scale.x, intakeHeight, this.dim.x / 2 - 25.41 * this.scale.x);
                                this.intake = new THREE.Mesh(intakeGeo, material);
                                intakeGeo.translate(0, this.trans.y + this.dim.y - height - cockHeight - intakeHeight / 2, 0); 
                        */


                let intakeHeight = 22.71 * this.scale.y;
                let intakeGeo = new THREE.CylinderGeometry((this.dim.x / 2 - 25.41 * this.scale.x) / 2, (this.dim.x / 2 - 25.41 * this.scale.x), intakeHeight);
                this.intake = new THREE.Mesh(intakeGeo, material);
                intakeGeo.translate(0, this.trans.y + this.dim.y - height - cockHeight - intakeHeight / 2, 0);

                let wingHeight = 26.14 * this.scale.y;
                let wingShape = new THREE.Shape();
                wingShape.moveTo(this.trans.x + 25.41 * this.scale.x, this.trans.y + 21.94 * this.scale.y);
                wingShape.lineTo(this.trans.x + 0, this.trans.y + 18.36 * this.scale.y);
                wingShape.lineTo(this.trans.x + 0, this.trans.y + 28.37 * this.scale.y);
                wingShape.lineTo(this.trans.x + 25.41 * this.scale.x, this.trans.y + 48.08 * this.scale.y);
                // wingShape.lineTo(this.trans.x + 25.41 * this.scale.x, this.trans.y + 70.79 * this.scale.y);
                wingShape.lineTo(this.trans.x + 30.67 * this.scale.x, this.trans.y + (48.08 + 3) * this.scale.y);

                wingShape.lineTo(this.trans.x + (this.dim.x / this.scale.x - 30.67) * this.scale.x, this.trans.y + (48.08 + 3) * this.scale.y);
                // wingShape.lineTo(this.trans.x + (this.dim.x / this.scale.x - 25.41) * this.scale.x, this.trans.y + 70.79 * this.scale.y);
                wingShape.lineTo(this.trans.x + (this.dim.x / this.scale.x - 25.41) * this.scale.x, this.trans.y + 48.08 * this.scale.y);
                wingShape.lineTo(this.trans.x + (this.dim.x / this.scale.x - 0) * this.scale.x, this.trans.y + 28.37 * this.scale.y);
                wingShape.lineTo(this.trans.x + (this.dim.x / this.scale.x - 0) * this.scale.x, this.trans.y + 18.36 * this.scale.y);
                wingShape.lineTo(this.trans.x + (this.dim.x / this.scale.x - 25.41) * this.scale.x, this.trans.y + 21.94 * this.scale.y);
                let extrudeSettings = {
                    steps: 1,
                    depth: 3 * this.scale.z,
                    bevelEnabled: true,
                    bevelThickness: 0,
                    bevelSize: 0,
                    bevelSegment: 2
                };
                let wingGeo = new THREE.ExtrudeGeometry(wingShape, extrudeSettings)
                this.wing = new THREE.Mesh(wingGeo, material);

                let fuselageHeight = 42.08 * this.scale.y;
                let fuselageGeo = new THREE.CylinderGeometry((this.dim.x / 2 - 25.41 * this.scale.x), (this.dim.x / 2 - 25.41 * this.scale.x),
                    fuselageHeight);
                this.fuselage = new THREE.Mesh(fuselageGeo, material);
                fuselageGeo.translate(0, this.trans.y + 6 * this.scale.y + fuselageHeight / 2, 0);


                let tailShape = new THREE.Shape();
                tailShape.moveTo(this.trans.x + 25.41 * this.scale.x, this.trans.y + 6 * this.scale.y);
                tailShape.lineTo(this.trans.x + 15 * this.scale.x, this.trans.y + 0 * this.scale.y);
                tailShape.lineTo(this.trans.x + 11.90 * this.scale.x, this.trans.y + 4.63 * this.scale.y);
                tailShape.lineTo(this.trans.x + 25.41 * this.scale.x, this.trans.y + 18.8 * this.scale.y);

                tailShape.lineTo(this.trans.x + (this.dim.x / this.scale.x - 25.41) * this.scale.x, this.trans.y + 18.8 * this.scale.y);
                tailShape.lineTo(this.trans.x + (this.dim.x / this.scale.x - 11.90) * this.scale.x, this.trans.y + 4.63 * this.scale.y);
                tailShape.lineTo(this.trans.x + (this.dim.x / this.scale.x - 15) * this.scale.x, this.trans.y + 0 * this.scale.y);
                tailShape.lineTo(this.trans.x + (this.dim.x / this.scale.x - 25.41) * this.scale.x, this.trans.y + 6 * this.scale.y);

                let tailGeo = new THREE.ExtrudeGeometry(tailShape, extrudeSettings);
                this.tail = new THREE.Mesh(tailGeo, material);

                let engineHeight = 6 * this.scale.y;
                let engineGeo = new THREE.CylinderGeometry((this.dim.x / 2 - 25.41 * this.scale.x), (this.dim.x / 2 - 27 * this.scale.x), engineHeight);
                this.engine = new THREE.Mesh(engineGeo, new THREE.MeshPhongMaterial({ color: 0x000F00 }));
                engineGeo.translate(0, this.trans.y + engineHeight / 2, 0);

                this.ship = new THREE.Group();

                this.sprite = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.05, 0.375), new THREE.MeshPhongMaterial({ color: 0x00ff00 }));
                this.sprite.position.y = 1;
                // this.sprite.castShadow = true;

                this.ship.add(this.nose, this.cockpit, this.intake, this.wing, this.fuselage, this.tail, this.engine);
                this.ship.rotateX(-Math.PI / 2);
            }

            getX() {
                return this.ship.position.x;
            }
            getY() {
                return this.ship.position.y;
            }
            getZ() {
                return this.ship.position.z;
            }

            setX(x) {
                this.ship.position.x = x;
            }
            setY(y) {
                this.ship.position.y = y;
            }
            setZ(z) {
                this.ship.position.z = z;
            }

            yaw(angle) {
                this.ship.rotation.z += angle;
            }
            roll(angle) {
                this.ship.rotation.y += angle;
            }
            pitch(angle) {
                this.ship.rotation.x += angle;
            }

            getYaw() {
                return this.ship.rotation.z;
            }

            getRoll() {
                return this.ship.rotation.y;
            }

            getPitch() {
                return this.ship.rotation.x + Math.PI / 2;
            }

            keyPressed = {};

            handleKeyDown(event) {
                let k = event.key;
                if (k == 'Control' || k == 'ArrowUp' || k == 'ArrowDown' || k == 'ArrowLeft' || k == 'ArrowRight') {
                    this.keyPressed[k] = true;
                }
                if (k == 'Escape') {
                    paused = true;
                    // console.log("clicked", document.getElementById('paused-panel'))
                    document.getElementById('paused-panel').style.display = 'flex';
                }
            }
            handleKeyUp(event) {
                let k = event.key;
                if (k == 'Control' || k == 'ArrowUp' || k == 'ArrowDown' || k == 'ArrowLeft' || k == 'ArrowRight') {
                    this.keyPressed[k] = false;
                }
            }

            handleKeyEvent(code, scene) {
                // console.log("Key pressed working!!");
                if (code == this.RIGHT) {
                    // this.ship.rotation.y += toRad(5);
                    this.ship.rotation.z += toRad(-0.5);
                    if (this.ship.rotation.z < toRad(-35)) {
                        this.ship.rotation.z = toRad(-35);
                    }



                } else if (code == this.LEFT) {
                    //     this.ship.rotation.y += toRad(-5);
                    // console.log("RRR", toDeg(this.ship.rotation.z));
                    this.ship.rotation.z += toRad(0.5);
                    if (this.ship.rotation.z > toRad(35)) {
                        this.ship.rotation.z = toRad(35);
                    }
                    //      sam.magic();

                } else if (code == this.DOWN) {
                    this.ship.rotation.x += toRad(1);

                } else if (code == this.UP) {
                    this.ship.rotation.x += toRad(-1);
                } if (code == this.FIRE_CANNON && this.can_fire === true) {
                    let cannon = new Cannon(this.getX(), this.getY(), this.getZ(), this.getPitch(), this.ship.rotation.z, scene);
                    this.weapons.push(cannon);
                    cannon.fire();
                    this.can_fire = false;
                    /*  console.log("Sam state", sam.state)
                     if (sam.state == sam.IDLE) {
                         sam.engage();
                     }
                     else if (sam.state === sam.READY) {
                         console.log("Told to explode");
                         sam.explode();
                     } else if (sam.state === sam.DESTRUCTING) {
                         sam.state = sam.READY;
                     }
                     console.log("Sam state", sam.state) */
                }
            }
            can_fire = true;
            count = 0; // Number of missiles fired
            move(camera, light) {
                if (this.state === this.STATE_ALIVE) {
                    if (this.keyPressed['Control'] === true && this.can_fire === true) {
                        this.handleKeyEvent(this.FIRE_CANNON, scene);
                        window.setTimeout(() => {
                            if (this.can_fire === false)
                                this.can_fire = true;
                        }, 200);
                    }
                    if (this.keyPressed['ArrowLeft'] === true) {
                        this.handleKeyEvent(this.LEFT, scene);
                    } else if (this.keyPressed['ArrowRight'] === true) {
                        this.handleKeyEvent(this.RIGHT, scene);
                    }
                    if (this.keyPressed['ArrowUp'] === true) {
                        this.handleKeyEvent(this.UP, scene);
                    } else if (this.keyPressed['ArrowDown'] === true) {
                        this.handleKeyEvent(this.DOWN, scene)
                    }

                    this.weapons.forEach((weap) => {
                        weap.move();
                    });

                    let uz = this.velocity.z;
                    let vz = uz - this.acc.z;

                    let cosB = Math.cos(this.ship.rotation.y);



                    let px = this.getX();
                    let pz = this.getZ();
                    let py = this.getY();

                    let tx = Math.sin(this.getYaw()) * -vz;
                    let tz = -vz;// Math.cos(this.getYaw()) * -vz * Math.cos(this.getPitch());
                    let ty = Math.sin(this.getPitch()) * vz;

                    this.velocity.y = Math.max(this.MAX_VELOCITY, ty);
                    this.velocity.x = Math.max(this.MAX_VELOCITY, tx);
                    this.velocity.z = Math.max(this.MAX_VELOCITY, tz);


                    let sinA = Math.sin(this.getYaw());
                    let cosA = Math.cos(this.getYaw());
                    let SinB = Math.sin(this.getPitch());

                    let dx = px * cosA - pz * sinA + (px + tx) - px * cosA + pz * sinA;
                    let dz = px * sinA + pz * cosA + (pz + tz) - pz * cosA - px * sinA;
                    let dy = py + ty;

                    if (dy > 12.5) {
                        dy = 12.5;
                        // console.log("SHo", toDeg(this.ship.rotation.x));
                    } else if (dy < 6.0) {
                        dy = 6.0; 0
                    }
                    if (dx > (PLAIN_DIMEN.x / 2 - this.dim.x / 2)) {
                        dx = PLAIN_DIMEN.x / 2 - this.dim.x / 2;
                    } else if (dx < (-PLAIN_DIMEN.x / 2 + this.dim.x / 2)) {
                        dx = -PLAIN_DIMEN.x / 2 + this.dim.x / 2;
                    }


                    this.setX(dx);
                    this.setY(dy);
                    this.setZ(dz);



                    if (this.getPitch() !== 0) {
                        let diff = this.getPitch();

                        this.ship.rotation.x -= (diff * delta) / 2;
                    }

                    if (this.ship.rotation.z !== 0) {
                        let diff = this.ship.rotation.z;

                        this.ship.rotation.z -= (diff * delta) / 2;
                    }



                    score += Math.abs(distanceZ - this.getZ()) * 2;
                    distanceZ = this.getZ();
                    document.getElementById('score').innerHTML = score.toFixed(0);
                    //     console.log("Collide", this.rocking);
                    if (this.rocking === true) { // Must have been hit or something
                        camera.position.x += this.rocking_count * ((this.rocking_count % 2 === 0) ? -1 : 1);
                        this.rocking_count--;
                        //       console.log("Collide", "Rocking", "jamming", this.rocking_count);
                        if (this.rocking_count <= 0) {
                            this.rocking = false;
                        }
                    }
                    if (distanceZ < -3300) {
                        // game Over
                        paused = true;
                        document.getElementById('game-over-panel').style.display = 'flex';
                        document.getElementById('score-title-text').innerHTML = "Score: " + score.toFixed(0);
                        document.getElementById('title-text').innerHTML = 'Congratulation';
                    }
                } else if (this.state === this.STATE_DYING) {
                    this.dying();
                } else if (this.state === this.STATE_RESURECTING) {
                    this.resurrecting();
                }
                else if (this.state === this.STATE_DEAD) {
                    this.state = this.STATE_DEAD;
                }

            }

            die() {
                this.state = this.STATE_DYING;
            }

            dying() {
                this.setZ(this.getZ() - this.MAX_VELOCITY)
                this.setY(this.getY() - 0.05);
                this.ship.rotation.x -= 0.03;
                this.ship.rotation.y += 0.03;
                this.ship.rotation.z -= 0.03;
                if (this.getY() <= 0) {
                    this.died();
                }
            }
            timeOut() {
                // console.log("Timeout", 'called')
                let countElement = document.getElementById('count-down');
                let count = Number(countElement.innerHTML);
                count--;
                if (count >= 0) {
                    // console.log("timeout", count);
                    countElement.innerHTML = count;
                    // console.log("timeout", countElement);
                    window.setTimeout(() => {
                        this.timeOut();
                    }, 1000);
                } else {
                    let countContElement = document.getElementById('count-container');
                    countContElement.style.display = 'none';
                    countElement.innerHTML = 5;
                    health = 100;
                    let healthElement = document.getElementById('health');
                    healthElement.style.width = health + '%';
                }
            }
            died() {
                this.state = this.STATE_DEAD;
                paused = true;
                this.live--;
                // live = 2
                //  <img id="img_live1" src="./images/live_.svg">


                // console.log("Died", "Just died live:", this.live);
                if (this.live < 0) {
                    document.getElementById('game-over-panel').style.display = 'flex';
                    document.getElementById('score-title-text').innerHTML = "Score: " + score.toFixed(0);
                } else {
                    document.getElementById('img_live' + (this.live + 1)).src = "./images/live_1.svg";
                    // console.log("I am ordered to Resurrect")
                    let countContElement = document.getElementById('count-container');
                    countContElement.style.display = 'flex';
                    window.setTimeout(() => {
                        this.timeOut();
                    }, 1000);

                    window.setTimeout(() => {
                        this.resurrect();
                    }, 1000);

                }

            }

            resurrecting() {
                // console.log("Resurrecting", this.getY());
                /* let dx = 0 - this.getX();
                let dy = 10 - this.getY();
                let dAx = Math.PI / 2; - this.ship.rotation.x;
                let dAy = 0 - this.ship.rotation.y;
                let dAz = 0 - this.ship.rotation.z;
 */
                let FRAMES = 120;

                this.setX(this.getX() + (this.resurrect_values.dx / FRAMES));
                this.setY(this.getY() + (this.resurrect_values.dy / FRAMES));
                this.ship.rotation.x = (this.ship.rotation.x + (this.resurrect_values.dAx / FRAMES));
                this.ship.rotation.y = (this.ship.rotation.y + (this.resurrect_values.dAy / FRAMES));
                this.ship.rotation.z = (this.ship.rotation.z + (this.resurrect_values.dAz / FRAMES));
                if (this.getY() >= 9.9) {
                    this.state = this.STATE_ALIVE;
                    // this.ship.rotation.set()
                }
            }
            resurrect_values = {};
            resurrect() {
                this.resurrect_values = {
                    dx: 0 - this.getX(),
                    dy: 10 - this.getY(),
                    dAx: -Math.PI / 2 - this.ship.rotation.x,
                    dAy: 0 - this.ship.rotation.y,
                    dAz: 0 - this.ship.rotation.z
                }
                this.state = this.STATE_RESURECTING;
                SAMS.forEach((s) => {
                    scene.remove(s.getMesh());
                    s.missiles.forEach((m) => {
                        scene.remove(m.getMesh());
                    })
                })
                SAMS = [];
                paused = false;
                this.rocking_count = 0;
                this.rocking = false;

            }

            rock() {
                this.rocking = true;
                this.rocking_count = 10;
                // console.log("Collide", " MAYDAY!!!!!! COllided !!!!!!", this.rocking, "and", this.rocking_count);
            }

            rocking_count = 0;
            rocking = false;

            getMesh() {
                //  return this.sprite;
                return this.ship;
            }
        }
        var delta = 0;
        THREE.ImageUtils.crossOrigin = "";

        function initTHREEJS() {

            let scene = new THREE.Scene();




            let camera = new THREE.PerspectiveCamera(
                75, // field of view
                window.innerWidth / window.innerHeight, // aspect ratio
                0.1, // inner view
                1000 // outer view
            );


            //     camera.position.x = 0;

            let light = new THREE.SpotLight(
                0xFFFFFF// color
                , 1 // intensity
                , 500 // position
            );
            light.shadow.mapSize.width = 2024;
            light.shadow.mapSize.height = 2024;
            // light.castShadow = true;
            light.position.set(0, 5, 5);
            //    light.lookAt(0, 0, 0);
            const canvas = document.getElementById('img-back');
            // console.log("render", canvas);
            let renderer = new THREE.WebGLRenderer(
                { canvas, alpha: true, antialias: true }
            );
            //          renderer.setClearColor('#202020');
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            //       renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            //           document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });
            let mouse = new THREE.Vector2();
            return {
                scene: scene,
                camera: camera,
                renderer: renderer,
                light: light,
            };
        }

        const { scene, camera, renderer, light } = initTHREEJS();
        var mouse = new THREE.Vector2();
        function onMouseClick(event) {
            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(scene.children, true);
            //      console.log(intersects);
            for (let i = 0; i < intersects.length; i++) {
                intersects[i].object.material.color.set(0xFF0000);
                this.t1 = new TimelineMax(.3);

                this.t1.to(this.mesh.position, 0.5, { x: 0.5, ease: Expo.easeOut });
                this.t1.to(this.mesh.rotation, 0.5, { z: Math.PI * 0.5, ease: Expo.easeOut });
            }
        }
        //     document.getElementsByTagName('body')[0].onKeyDown = (e)=>{
        //    //     ship.handleKeyEvent(e.which, scene);
        //     };
        $(document.body).on('keydown', function (e) {
            // ship.handleKeyEvent(e.which, scene);
            ship.handleKeyDown(e);
        });
        $(document.body).on('keyup', (e) => {
            ship.handleKeyUp(e);
        })


        const PLAIN_DIMEN = {
            x: 30,
            y: 15,
            z: 3500,
        };

        var distanceZ = 0;

        const geometry = new THREE.CylinderGeometry(2, 2, 1000, 48, 48, true, 0, 2 * Math.PI);
        const material = new THREE.MeshLambertMaterial({ color: 0x2F2F00, wireframe: true });
        const cylinder = new THREE.Mesh(geometry, material);
        cylinder.rotation.x = Math.PI / 2;




        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(PLAIN_DIMEN.x, 300),
            new THREE.MeshPhongMaterial({ color: 0x1F1FFF, side: THREE.DoubleSide })
        );
        plane.position.z -= 3350;
        plane.position.y += 0.3;
        // plane.castShadow = false;
        // plane.receiveShadow = true;
        plane.rotation.x = Math.PI / 2;

        function createScene() {
            let shape2 = new THREE.Shape();
            let tx = -PLAIN_DIMEN.x / 2;
            let ty = 0;
            let tz = 0;
            let h = PLAIN_DIMEN.y / 2;
            let w = PLAIN_DIMEN.x;
            let d = PLAIN_DIMEN.z;
            let m = 0.25;

            shape2.moveTo(tx + 0, ty + h); // A
            shape2.lineTo(tx + m, ty + h); // B
            shape2.lineTo(tx + m, ty + m); // C
            shape2.lineTo(tx + w - m, ty + m); // D
            shape2.lineTo(tx + w - m, ty + h); // E
            shape2.lineTo(tx + w, ty + h); // F
            shape2.lineTo(tx + w, ty + 0);// G
            shape2.lineTo(tx + 0, ty + 0); // H


            // shape2.moveTo(this.dim.x * 0.2 + this.trans.x, 0 + this.trans.y);
            // shape2.arc(-this.dim.x * 0.15 / 2, 0, this.dim.x * 0.15 / 2, 0, Math.PI, false);

            let extrudeSettings2 = {
                steps: 2,
                depth: PLAIN_DIMEN.z,
                bevelEnabled: true,
                bevelThickness: 0,
                bevelSegment: 2,
                bevelSize: 0
            };
            let mesh3 = new THREE.Mesh(new THREE.ExtrudeGeometry(shape2, extrudeSettings2),
                new THREE.MeshPhongMaterial({ color: 0xFFFFFF, transparent: false, opacity: 1 }));
            mesh3.position.y -= m;
            mesh3.position.z -= PLAIN_DIMEN.z;
            mesh3.receiveShadow = true;
            return mesh3;
        }





        var toRad = (angle) => {
            return angle * Math.PI / 180; d
        }

        var toDeg = (angle) => {
            return angle * 180 / Math.PI;
        }

        const ship = new Ship();

        //       const sams = [];
        var lastDistanceZ = 160;
        function addSAMtoScene() {
            if (paused === false && (lastDistanceZ - ship.getZ()) > 100 && ((ship.getZ() - 400) > -3500)) {
                let shiftz = [0, 20, 40, 55]
                for (let i = 0; i < shiftz.length; i++) {
                    // console.log("Interval fired " + (25 * ship.velocity.z) + " shiP : " + ship.getZ());
                    const sss = new SAMLauncher(0, 0);
                    let x = -PLAIN_DIMEN.x / 2 + sss.dim.x / 2 + Math.random() * (PLAIN_DIMEN.x - sss.dim.x);
                    sss.setX(x);
                    sss.setZ(ship.getZ() - 400 - shiftz[i]);
                    scene.add(sss.getMesh());
                    sss.addMissiles(scene);
                    SAMS.push(sss);
                    lastDistanceZ = distanceZ;
                }
            } else {
                // console.log("Interval Rejected: " + (lastDistanceZ - ship.getZ()));

            }
        }


        window.setInterval(addSAMtoScene, 2000);

        // ship.getMesh().position.set(0, 10, 0)
        ship.setY(10.5);
        ship.setZ(10);
        ship.setX(0);

        // console.log("Resurrection", toDeg(ship.getMesh().rotation.x), toDeg(ship.getMesh().rotation.y), toDeg(ship.getMesh().rotation.z))

        camera.position.z = ship.getZ() + 2.5;//-= (camera.position.z - this.getZ() - this.cameraOffset.z) * delta + this.velocity.z * cosB;
        camera.position.y = ship.getY() + 1.5;// -= (camera.position.y - this.getY() - this.cameraOffset.y) * delta;
        camera.position.x = ship.getX() - 0;// -= (camera.position.x - this.getX() - this.cameraOffset.x) * delta;
        camera.lookAt(ship.getX(), ship.getY(), ship.getZ());
        light.position.z = camera.position.z + 2;

        // camera.position.z = ship.getZ() + 3;
        // camera.position.x = ship.getX() + 0;
        // camera.position.y = ship.getY() + 3;
        // light.position.z = camera.position.z + 2;
        /*       const sam = new SAMLauncher(0, 0);
              sam.setX(0);
              sam.setZ(-5);
              scene.add(sam.getMesh())
              sam.addMissiles(scene);
       */
        // sam.setZ(-2);

        //    ship.yaw(toRad(5));
        //      light.target = ship.getMesh();
        const helper = new THREE.CameraHelper(light.shadow.camera);

        scene.add(camera);
        //     scene.add(cylinder);
        scene.add(plane);
        scene.add(createScene());
        var ss = createScene();
        ss.rotation.z = Math.PI;
        ss.position.y += PLAIN_DIMEN.y / 1;
        //   scene.add(ss);



        LIGHTS = [];
        let numberOfLights = PLAIN_DIMEN.z / 100;
        for (let i = 0; i < (numberOfLights); i++) {
            var spotLight = new THREE.SpotLight((i % 2 === 0) ? 0xFFFFFF : 0xFFFFFF);
            spotLight.position.set(0, PLAIN_DIMEN.y * 2, -(PLAIN_DIMEN.z / numberOfLights) * i);
            var spotTarget = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.01, 0.01),
                new THREE.MeshBasicMaterial());
            spotTarget.position.set(0, 0, -(PLAIN_DIMEN.z / numberOfLights) * i);
            spotLight.target = spotTarget;
            LIGHTS.push(spotLight);
            scene.add(spotLight.target);
            scene.add(spotLight);
        }

        scene.add(ship.getMesh());


        // const controls = new THREE.OrbitControls(camera, renderer.domElement);
        var number = 45;

        const clock = new THREE.Clock();


        var cameraOffset = {
            x: 1.7,
            y: 0.7,
            z: 1.7
        }

        const duration = Number.MAX_VALUE - Number.MAX_VALUE + 1.2; // 2 seconds maneurverA
        var paused = true;
        var score = 0;
        var health = 100;

        var repeatMe = function () {
            number++;
            delta = clock.getDelta();
            requestAnimationFrame(repeatMe);




            // controls.update();


            // sam.move();
            if (paused === false) {
                camera.lookAt(ship.getX(), ship.getY(), ship.getZ());
                camera.position.z = ship.getZ() + 2.5;//-= (camera.position.z - this.getZ() - this.cameraOffset.z) * delta + this.velocity.z * cosB;
                camera.position.y = ship.getY() + 1.5;// -= (camera.position.y - this.getY() - this.cameraOffset.y) * delta;
                camera.position.x = ship.getX() - 0;// -= (camera.position.x - this.getX() - this.cameraOffset.x) * delta;
                light.position.z = camera.position.z + 2;
                ship.move(camera, light);
                SAMS.forEach((s) => {
                    s.move();
                });
                LIGHTS.forEach((sl, i) => {
                    if (Math.abs(ship.getZ() - sl.position.z) < 10) {
                        console.log("EYi", i)
                     //   sl.castShadow = true;
                 //       sl.shadow.mapSize.width = 2048;
                   //     sl.shadow.mapSize.height = 2048;
                        return;
                    } else {
                        spotLight.castShadow = false;
                    }
                })
            }
            renderer.render(scene, camera);

        }
        repeatMe();

    </script>
</body>

</html>